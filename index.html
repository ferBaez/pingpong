<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Básico -->
    <title>Neon Pong Ultimate - Juego Arcade Cyberpunk Gratis Online</title>
    <meta name="description" content="Juega Neon Pong Ultimate gratis online. Una versión moderna y responsive del clásico ping pong con gráficos de neón, física realista y modo para un jugador.">
    <meta name="keywords" content="pong, neon pong, juego arcade, html5, juego gratis, ping pong online, cyberpunk game, juego retro">
    <meta name="author" content="Neon Dev">
    <meta name="robots" content="index, follow">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tudominio.com/">
    <meta property="og:title" content="Neon Pong Ultimate - Juego Arcade Cyberpunk">
    <meta property="og:description" content="Desafía a la IA en esta versión futurista del clásico Pong. Gráficos de neón, partículas y adrenalina pura.">
    <meta property="og:image" content="https://tudominio.com/thumbnail.jpg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="Neon Pong Ultimate">
    <meta property="twitter:description" content="Juega al Pong más moderno de la web. Estilo Neón y jugabilidad fluida.">

    <!-- JSON-LD para AEO (Answer Engine Optimization) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Neon Pong Ultimate",
      "description": "Una reimaginación cyberpunk del clásico juego de arcade Pong, con efectos de partículas y diseño responsivo.",
      "genre": ["Arcade", "Casual", "Retro"],
      "gamePlatform": "Web Browser",
      "applicationCategory": "Game",
      "operatingSystem": "Any",
      "inLanguage": "es",
      "author": {
        "@type": "Person",
        "name": "Neon Dev"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD",
        "category": "free"
      }
    }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --color-bg: #050505;
            --color-primary: #00f3ff;
            --color-secondary: #ff0055;
            --font-main: 'Orbitron', sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--color-bg);
            color: #fff;
            font-family: var(--font-main);
            overflow: hidden; /* Evita scroll en móviles */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Contenedor principal semántico para SEO */
        main {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            position: relative;
        }

        #game-wrapper {
            position: relative;
            transition: transform 0.1s;
            max-width: 100%;
            max-height: 100%;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #1a1a2e;
            background: #000;
        }

        canvas {
            display: block;
            background: radial-gradient(circle at center, #11111f 0%, #000000 100%);
            touch-action: none; /* Crucial para AEO/UX móvil: evita gestos del navegador */
        }

        /* UI Overlay Elements */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .score-board {
            display: flex;
            justify-content: center;
            font-size: clamp(3rem, 10vw, 5rem); /* Responsive typography */
            font-weight: 700;
            padding-top: 2vh;
            z-index: 10;
            mix-blend-mode: screen;
        }

        .score {
            margin: 0 5vw;
            opacity: 0.6;
            transition: transform 0.2s;
        }

        .score.bump {
            transform: scale(1.5);
            opacity: 1;
        }

        .player-score { color: var(--color-primary); text-shadow: 0 0 30px var(--color-primary); }
        .ai-score { color: var(--color-secondary); text-shadow: 0 0 30px var(--color-secondary); }

        .message-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            background: rgba(10, 10, 15, 0.95);
            padding: 5vh 5vw;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.15);
            backdrop-filter: blur(10px);
            transition: opacity 0.3s, transform 0.3s;
            width: 80%;
            max-width: 500px;
            box-sizing: border-box;
        }

        h1 {
            font-size: clamp(2rem, 6vw, 3.5rem);
            margin: 0 0 15px 0;
            background: linear-gradient(90deg, var(--color-primary), #fff, var(--color-secondary));
            background-size: 200% auto;
            animation: shine 3s linear infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 900;
        }

        @keyframes shine {
            to { background-position: 200% center; }
        }

        p {
            font-size: clamp(0.8rem, 3vw, 1rem);
            color: #aaa;
            margin-bottom: 30px;
            letter-spacing: 1px;
            text-transform: uppercase;
            line-height: 1.5;
        }

        button {
            background: transparent;
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
            padding: 15px 40px;
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            font-family: var(--font-main);
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            width: 100%;
            max-width: 300px;
        }

        button:hover {
            background: rgba(0, 243, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.6);
            border-color: #fff;
            color: #fff;
        }

        button:active {
            transform: scale(0.98);
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -60%);
        }

        /* Countdown Overlay */
        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(5rem, 20vw, 8rem);
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 20;
        }
        
        #countdown.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: #444;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Footer oculto visualmente pero accesible para crawlers (SEO Text) */
        .seo-content {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>

    <main>
        <div id="game-wrapper">
            <div id="game-container">
                <canvas id="pongCanvas" aria-label="Tablero de juego Neon Pong"></canvas>
                
                <div class="ui-layer">
                    <div class="score-board">
                        <div class="score player-score" id="playerScore" title="Puntuación Jugador">0</div>
                        <div class="score ai-score" id="aiScore" title="Puntuación IA">0</div>
                    </div>
                    <div id="countdown" aria-live="polite">3</div>
                    <div class="controls-hint">Desliza para mover</div>
                </div>

                <!-- Sección semántica para inicio -->
                <section id="startScreen" class="message-container">
                    <header>
                        <h1>Neon Pong</h1>
                    </header>
                    <p>Desafía a la IA en este clásico modernizado.<br>El primero en llegar a 5 puntos gana la partida.</p>
                    <button onclick="startGame()" aria-label="Comenzar juego">Iniciar Sistema</button>
                </section>

                <section id="gameOverScreen" class="message-container hidden" aria-hidden="true">
                    <h1 id="winnerText">Ganaste</h1>
                    <p id="finalScore">5 - 3</p>
                    <button onclick="resetGame()">Reiniciar Partida</button>
                </section>
            </div>
        </div>
    </main>

    <!-- Contenido SEO/AEO (Invisible en UI pero indexable) -->
    <article class="seo-content">
        <h2>Sobre Neon Pong Ultimate</h2>
        <p>Neon Pong Ultimate es un juego arcade gratuito basado en el clásico Pong de 1972, reimaginado con una estética cyberpunk moderna, luces de neón y efectos de partículas.</p>
        
        <h3>¿Cómo se juega a Neon Pong?</h3>
        <p>El objetivo es golpear la pelota con tu paleta para que rebote hacia el lado del oponente. Si la pelota pasa la paleta del oponente, ganas un punto. El primer jugador en alcanzar 5 puntos gana.</p>
        
        <h3>Controles</h3>
        <ul>
            <li><strong>PC:</strong> Usa el mouse para mover la paleta verticalmente.</li>
            <li><strong>Móvil/Tablet:</strong> Toca y desliza el dedo en la pantalla para controlar la paleta.</li>
        </ul>
    </article>

    <script>
        // --- CONFIGURACIÓN ---
        const canvas = document.getElementById('pongCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimización de rendimiento
        const gameWrapper = document.getElementById('game-wrapper');
        
        let width, height;
        let animationId;
        
        // --- ESTADO DEL JUEGO ---
        const state = {
            running: false,
            waitingForServe: false,
            winningScore: 5,
            shake: 0,
            flash: 0
        };

        // --- AUDIO (Sintetizador Simple) ---
        // Se crea el contexto solo tras interacción del usuario para cumplir políticas de navegadores
        let audioCtx;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }
        
        function playSound(type) {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (type === 'hit') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'wall') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'score') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            }
        }

        // --- OBJETOS ---
        // Usamos tamaños relativos para responsive
        let paddleWidth = 12;
        let paddleHeight = 90;
        let ballSize = 8;
        
        const colors = {
            player: '#00f3ff',
            ai: '#ff0055',
            ball: '#ffffff',
            grid: 'rgba(255, 255, 255, 0.03)'
        };

        const player = {
            x: 0, y: 0, score: 0,
            color: colors.player,
            height: paddleHeight
        };

        const ai = {
            x: 0, y: 0, score: 0,
            speed: 5.5,
            color: colors.ai,
            height: paddleHeight
        };

        const ball = {
            x: 0, y: 0,
            speedX: 0, speedY: 0,
            baseSpeed: 9, // Ajustaremos esto en resize para móviles
            color: colors.ball,
            trail: [] 
        };

        // --- SISTEMA DE PARTÍCULAS ---
        let particles = [];
        class Particle {
            constructor(x, y, color, speedMulti = 1) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 3 + 1;
                let angle = Math.random() * Math.PI * 2;
                let speed = Math.random() * 5 * speedMulti;
                this.speedX = Math.cos(angle) * speed;
                this.speedY = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= this.decay;
                this.size *= 0.92;
            }
            draw(ctx) {
                if (this.life <= 0) return;
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function createExplosion(x, y, color, count = 15, intensity = 1) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color, intensity));
            }
        }

        // --- CORE & RESPONSIVE ---
        function resize() {
            // Lógica responsive mejorada
            // En móviles, queremos ocupar casi toda la pantalla
            const isMobile = window.innerWidth < 768;
            
            let margin = isMobile ? 0 : 40;
            const maxWidth = 1000;
            const maxHeight = 700;
            
            let w = window.innerWidth - margin;
            let h = window.innerHeight - margin;
            
            if (w > maxWidth) w = maxWidth;
            if (h > maxHeight) h = maxHeight;
            
            canvas.width = w;
            canvas.height = h;
            width = w;
            height = h;

            // Ajustar elementos según el tamaño
            paddleHeight = h * 0.15; // 15% de la altura
            if (paddleHeight > 100) paddleHeight = 100;
            if (paddleHeight < 60) paddleHeight = 60;

            player.height = paddleHeight;
            ai.height = paddleHeight;
            
            // Ajustar velocidad base según ancho de pantalla para mantener dificultad
            ball.baseSpeed = width * 0.01; 
            if (ball.baseSpeed < 6) ball.baseSpeed = 6;
            if (ball.baseSpeed > 10) ball.baseSpeed = 10;
            
            // Posiciones iniciales
            player.x = width * 0.05; // 5% desde la izquierda
            ai.x = width - (width * 0.05) - paddleWidth;
            
            if (!state.running && !state.waitingForServe) {
                resetPositions();
            }
        }
        
        // Debounce resize para rendimiento
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resize, 100);
        });
        
        // Input
        function movePaddle(clientY) {
            const rect = canvas.getBoundingClientRect();
            // Ajustar escala si el canvas CSS difiere del canvas real
            const scaleY = canvas.height / rect.height; 
            const relativeY = (clientY - rect.top) * scaleY;
            
            player.y = relativeY - player.height / 2;
            
            // Clamp
            if (player.y < 0) player.y = 0;
            if (player.y > height - player.height) player.y = height - player.height;
        }

        // Mouse & Touch events
        document.addEventListener('mousemove', (e) => {
             if(state.running || state.waitingForServe) movePaddle(e.clientY);
        });
        
        // Optimización AEO: Prevenir comportamientos por defecto del navegador en touch
        canvas.addEventListener('touchstart', (e) => {
             if(e.cancelable) e.preventDefault();
             if(state.running) initAudio(); // Init audio on touch
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if((state.running || state.waitingForServe)) {
                if(e.cancelable) e.preventDefault(); // Prevenir scroll
                movePaddle(e.touches[0].clientY);
            }
        }, { passive: false });


        // --- LÓGICA DE JUEGO ---
        function update() {
            // Shake decay
            if (state.shake > 0) {
                state.shake *= 0.9;
                if (state.shake < 0.5) state.shake = 0;
            }
            
            // Flash decay
            if (state.flash > 0) {
                state.flash -= 0.05;
                if (state.flash < 0) state.flash = 0;
            }

            if (state.waitingForServe) {
                // IA idle movement (sutil)
                let targetY = height / 2 - ai.height/2;
                ai.y += (targetY - ai.y) * 0.05;
                return; 
            }

            ball.trail.push({x: ball.x, y: ball.y});
            if (ball.trail.length > 10) ball.trail.shift();

            ball.x += ball.speedX;
            ball.y += ball.speedY;

            // IA
            const aiCenter = ai.y + ai.height / 2;
            let targetY = ball.y;
            
            // Nivel de dificultad adaptativo
            let aiReaction = 0.08; 
            
            if (ball.speedX > 0) {
                if (aiCenter < targetY - 20) ai.y += ai.speed + (Math.abs(ball.speedX) * 0.1);
                else if (aiCenter > targetY + 20) ai.y -= ai.speed + (Math.abs(ball.speedX) * 0.1);
            } else {
                 let center = height / 2 - ai.height/2;
                 ai.y += (center - ai.y) * 0.02;
            }
            
            if (ai.y < 0) ai.y = 0;
            if (ai.y > height - ai.height) ai.y = height - ai.height;

            // Rebotes Paredes
            if (ball.y - ballSize < 0 || ball.y + ballSize > height) {
                ball.speedY = -ball.speedY;
                ball.y = (ball.y < height/2) ? ballSize + 1 : height - ballSize - 1;
                playSound('wall');
                createExplosion(ball.x, ball.y, '#fff', 5);
            }

            // Colisiones Paletas
            if (checkCollision(player)) handleHit(player, 1);
            else if (checkCollision(ai)) handleHit(ai, -1);

            // Puntuación
            if (ball.x < -20) scorePoint('ai');
            else if (ball.x > width + 20) scorePoint('player');

            // Actualizar partículas
            particles.forEach((p, index) => {
                p.update();
                if (p.life <= 0) particles.splice(index, 1);
            });
        }

        function checkCollision(p) {
            return ball.x - ballSize < p.x + paddleWidth &&
                   ball.x + ballSize > p.x &&
                   ball.y - ballSize < p.y + p.height &&
                   ball.y + ballSize > p.y;
        }

        function handleHit(paddle, dir) {
            // Asegurar que la bola salga de la zona de colisión para evitar rebotes múltiples
            if (dir === 1) ball.x = paddle.x + paddleWidth + ballSize;
            else ball.x = paddle.x - ballSize;

            ball.speedX = -ball.speedX;
            ball.speedX *= 1.05;
            ball.speedY *= 1.05;
            
            const maxSpeed = width * 0.025; // Max speed relativa al ancho
            if (Math.abs(ball.speedX) > maxSpeed) ball.speedX = maxSpeed * Math.sign(ball.speedX);

            let hitPoint = (ball.y - (paddle.y + paddle.height/2)) / (paddle.height/2);
            ball.speedY = hitPoint * (ball.baseSpeed * 0.8);

            playSound('hit');
            state.shake = 5;
            createExplosion(
                dir === 1 ? paddle.x + paddleWidth : paddle.x, 
                ball.y, 
                paddle.color, 
                20, 1.5
            );
        }

        function scorePoint(winner) {
            playSound('score');
            state.shake = 15;
            state.flash = 0.6;
            
            if (winner === 'player') {
                player.score++;
                createExplosion(width, ball.y, colors.player, 50, 2);
            } else {
                ai.score++;
                createExplosion(0, ball.y, colors.ai, 50, 2);
            }

            updateScoreUI();
            
            if (player.score >= state.winningScore || ai.score >= state.winningScore) {
                endGame();
            } else {
                startRound();
            }
        }

        function updateScoreUI() {
            const pEl = document.getElementById('playerScore');
            const aEl = document.getElementById('aiScore');
            
            pEl.innerText = player.score;
            aEl.innerText = ai.score;
            
            pEl.classList.remove('bump');
            aEl.classList.remove('bump');
            void pEl.offsetWidth; 
            
            if(player.score > parseInt(pEl.getAttribute('data-prev') || 0)) pEl.classList.add('bump');
            if(ai.score > parseInt(aEl.getAttribute('data-prev') || 0)) aEl.classList.add('bump');
            
            pEl.setAttribute('data-prev', player.score);
            aEl.setAttribute('data-prev', ai.score);
        }

        // --- RENDER ---
        function draw() {
            ctx.save();
            let dx = (Math.random() - 0.5) * state.shake;
            let dy = (Math.random() - 0.5) * state.shake;
            ctx.translate(dx, dy);

            ctx.fillStyle = '#050505';
            ctx.fillRect(-state.shake, -state.shake, width + state.shake*2, height + state.shake*2);

            if (state.flash > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${state.flash * 0.1})`;
                ctx.fillRect(0, 0, width, height);
            }

            drawGrid();

            // Red central
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2, 0);
            ctx.lineTo(width/2, height);
            ctx.stroke();

            // Objetos
            drawGlowRect(player.x, player.y, paddleWidth, player.height, player.color);
            drawGlowRect(ai.x, ai.y, paddleWidth, ai.height, ai.color);

            if (!state.waitingForServe || state.running) {
                drawBallTrail();
                drawGlowCircle(ball.x, ball.y, ballSize, ball.color);
            }

            particles.forEach(p => p.draw(ctx));

            ctx.restore();
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.03)';
            ctx.lineWidth = 1;
            const gridSize = 40;
            
            // Dibujar solo líneas verticales para rendimiento
            for (let x = 0; x <= width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
        }

        function drawBallTrail() {
            for (let i = 0; i < ball.trail.length; i++) {
                const pos = ball.trail[i];
                const opacity = (i / ball.trail.length) * 0.4;
                const size = ballSize * (i / ball.trail.length);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawGlowRect(x, y, w, h, color) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
            
            ctx.shadowBlur = 0;
            ctx.fillStyle = "rgba(255,255,255,0.4)";
            ctx.fillRect(x+2, y+2, w-4, h-4);
        }

        function drawGlowCircle(x, y, r, color) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }


        // --- CONTROL DE FLUJO ---
        function startRound() {
            state.waitingForServe = true;
            resetPositions();
            
            let count = 3;
            const countEl = document.getElementById('countdown');
            
            function tick() {
                if (!state.running && count < 3) return;
                
                if (count > 0) {
                    countEl.innerText = count;
                    countEl.classList.add('active');
                    playSound('wall'); 
                    
                    setTimeout(() => {
                        countEl.classList.remove('active');
                        count--;
                        setTimeout(tick, 500); 
                    }, 500);
                } else {
                    countEl.innerText = "YA!";
                    countEl.classList.add('active');
                    playSound('hit');
                    launchBall();
                    setTimeout(() => {
                        countEl.classList.remove('active');
                        state.waitingForServe = false;
                    }, 500);
                }
            }
            tick();
        }

        function launchBall() {
            ball.speedX = (Math.random() > 0.5 ? 1 : -1) * ball.baseSpeed;
            ball.speedY = (Math.random() * 6) - 3;
            ball.trail = [];
        }

        function resetPositions() {
            ball.x = width / 2;
            ball.y = height / 2;
            ball.speedX = 0;
            ball.speedY = 0;
            player.y = height / 2 - player.height / 2;
            ai.y = height / 2 - ai.height / 2;
        }

        function startGame() {
            initAudio(); // Inicializar audio con interacción usuario
            
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('startScreen').setAttribute('aria-hidden', 'true');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            player.score = 0;
            ai.score = 0;
            updateScoreUI();
            
            state.running = true;
            resize(); 
            startRound();
            
            if (!animationId) loop();
        }

        function endGame() {
            state.running = false;
            
            const winText = document.getElementById('winnerText');
            const scoreText = document.getElementById('finalScore');
            const overlay = document.getElementById('gameOverScreen');
            
            overlay.setAttribute('aria-hidden', 'false');

            if (player.score > ai.score) {
                winText.innerText = "¡VICTORIA!";
                winText.style.color = colors.player;
            } else {
                winText.innerText = "DERROTA";
                winText.style.color = colors.ai;
            }

            scoreText.innerText = `${player.score} - ${ai.score}`;
            overlay.classList.remove('hidden');
        }

        function resetGame() {
            startGame();
        }

        function loop() {
            if (state.running) {
                update();
                draw();
            } else {
                draw(); 
            }
            animationId = requestAnimationFrame(loop);
        }

        // Init
        resize();
        draw();

    </script>
</body>
</html>
